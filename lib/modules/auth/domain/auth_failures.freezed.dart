// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'auth_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() emailAddressInvalid,
    required TResult Function() passwordInvalid,
    required TResult Function() fullNameInvalid,
    required TResult Function() unknow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AuthFailuresEmailAddressInvalid value)
        emailAddressInvalid,
    required TResult Function(AuthFailuresPasswordInvalid value)
        passwordInvalid,
    required TResult Function(AuthFailureFullNameInvalid value) fullNameInvalid,
    required TResult Function(AuthFailuresUnknow value) unknow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailuresCopyWith<$Res> {
  factory $AuthFailuresCopyWith(
          AuthFailures value, $Res Function(AuthFailures) then) =
      _$AuthFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailuresCopyWithImpl<$Res> implements $AuthFailuresCopyWith<$Res> {
  _$AuthFailuresCopyWithImpl(this._value, this._then);

  final AuthFailures _value;
  // ignore: unused_field
  final $Res Function(AuthFailures) _then;
}

/// @nodoc
abstract class _$$AuthFailuresEmailAddressInvalidCopyWith<$Res> {
  factory _$$AuthFailuresEmailAddressInvalidCopyWith(
          _$AuthFailuresEmailAddressInvalid value,
          $Res Function(_$AuthFailuresEmailAddressInvalid) then) =
      __$$AuthFailuresEmailAddressInvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuthFailuresEmailAddressInvalidCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$AuthFailuresEmailAddressInvalidCopyWith<$Res> {
  __$$AuthFailuresEmailAddressInvalidCopyWithImpl(
      _$AuthFailuresEmailAddressInvalid _value,
      $Res Function(_$AuthFailuresEmailAddressInvalid) _then)
      : super(_value, (v) => _then(v as _$AuthFailuresEmailAddressInvalid));

  @override
  _$AuthFailuresEmailAddressInvalid get _value =>
      super._value as _$AuthFailuresEmailAddressInvalid;
}

/// @nodoc

class _$AuthFailuresEmailAddressInvalid
    implements AuthFailuresEmailAddressInvalid {
  const _$AuthFailuresEmailAddressInvalid();

  @override
  String toString() {
    return 'AuthFailures.emailAddressInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthFailuresEmailAddressInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() emailAddressInvalid,
    required TResult Function() passwordInvalid,
    required TResult Function() fullNameInvalid,
    required TResult Function() unknow,
  }) {
    return emailAddressInvalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
  }) {
    return emailAddressInvalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
    required TResult orElse(),
  }) {
    if (emailAddressInvalid != null) {
      return emailAddressInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AuthFailuresEmailAddressInvalid value)
        emailAddressInvalid,
    required TResult Function(AuthFailuresPasswordInvalid value)
        passwordInvalid,
    required TResult Function(AuthFailureFullNameInvalid value) fullNameInvalid,
    required TResult Function(AuthFailuresUnknow value) unknow,
  }) {
    return emailAddressInvalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
  }) {
    return emailAddressInvalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
    required TResult orElse(),
  }) {
    if (emailAddressInvalid != null) {
      return emailAddressInvalid(this);
    }
    return orElse();
  }
}

abstract class AuthFailuresEmailAddressInvalid implements AuthFailures {
  const factory AuthFailuresEmailAddressInvalid() =
      _$AuthFailuresEmailAddressInvalid;
}

/// @nodoc
abstract class _$$AuthFailuresPasswordInvalidCopyWith<$Res> {
  factory _$$AuthFailuresPasswordInvalidCopyWith(
          _$AuthFailuresPasswordInvalid value,
          $Res Function(_$AuthFailuresPasswordInvalid) then) =
      __$$AuthFailuresPasswordInvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuthFailuresPasswordInvalidCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$AuthFailuresPasswordInvalidCopyWith<$Res> {
  __$$AuthFailuresPasswordInvalidCopyWithImpl(
      _$AuthFailuresPasswordInvalid _value,
      $Res Function(_$AuthFailuresPasswordInvalid) _then)
      : super(_value, (v) => _then(v as _$AuthFailuresPasswordInvalid));

  @override
  _$AuthFailuresPasswordInvalid get _value =>
      super._value as _$AuthFailuresPasswordInvalid;
}

/// @nodoc

class _$AuthFailuresPasswordInvalid implements AuthFailuresPasswordInvalid {
  const _$AuthFailuresPasswordInvalid();

  @override
  String toString() {
    return 'AuthFailures.passwordInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthFailuresPasswordInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() emailAddressInvalid,
    required TResult Function() passwordInvalid,
    required TResult Function() fullNameInvalid,
    required TResult Function() unknow,
  }) {
    return passwordInvalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
  }) {
    return passwordInvalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
    required TResult orElse(),
  }) {
    if (passwordInvalid != null) {
      return passwordInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AuthFailuresEmailAddressInvalid value)
        emailAddressInvalid,
    required TResult Function(AuthFailuresPasswordInvalid value)
        passwordInvalid,
    required TResult Function(AuthFailureFullNameInvalid value) fullNameInvalid,
    required TResult Function(AuthFailuresUnknow value) unknow,
  }) {
    return passwordInvalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
  }) {
    return passwordInvalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
    required TResult orElse(),
  }) {
    if (passwordInvalid != null) {
      return passwordInvalid(this);
    }
    return orElse();
  }
}

abstract class AuthFailuresPasswordInvalid implements AuthFailures {
  const factory AuthFailuresPasswordInvalid() = _$AuthFailuresPasswordInvalid;
}

/// @nodoc
abstract class _$$AuthFailureFullNameInvalidCopyWith<$Res> {
  factory _$$AuthFailureFullNameInvalidCopyWith(
          _$AuthFailureFullNameInvalid value,
          $Res Function(_$AuthFailureFullNameInvalid) then) =
      __$$AuthFailureFullNameInvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuthFailureFullNameInvalidCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$AuthFailureFullNameInvalidCopyWith<$Res> {
  __$$AuthFailureFullNameInvalidCopyWithImpl(
      _$AuthFailureFullNameInvalid _value,
      $Res Function(_$AuthFailureFullNameInvalid) _then)
      : super(_value, (v) => _then(v as _$AuthFailureFullNameInvalid));

  @override
  _$AuthFailureFullNameInvalid get _value =>
      super._value as _$AuthFailureFullNameInvalid;
}

/// @nodoc

class _$AuthFailureFullNameInvalid implements AuthFailureFullNameInvalid {
  const _$AuthFailureFullNameInvalid();

  @override
  String toString() {
    return 'AuthFailures.fullNameInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthFailureFullNameInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() emailAddressInvalid,
    required TResult Function() passwordInvalid,
    required TResult Function() fullNameInvalid,
    required TResult Function() unknow,
  }) {
    return fullNameInvalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
  }) {
    return fullNameInvalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
    required TResult orElse(),
  }) {
    if (fullNameInvalid != null) {
      return fullNameInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AuthFailuresEmailAddressInvalid value)
        emailAddressInvalid,
    required TResult Function(AuthFailuresPasswordInvalid value)
        passwordInvalid,
    required TResult Function(AuthFailureFullNameInvalid value) fullNameInvalid,
    required TResult Function(AuthFailuresUnknow value) unknow,
  }) {
    return fullNameInvalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
  }) {
    return fullNameInvalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
    required TResult orElse(),
  }) {
    if (fullNameInvalid != null) {
      return fullNameInvalid(this);
    }
    return orElse();
  }
}

abstract class AuthFailureFullNameInvalid implements AuthFailures {
  const factory AuthFailureFullNameInvalid() = _$AuthFailureFullNameInvalid;
}

/// @nodoc
abstract class _$$AuthFailuresUnknowCopyWith<$Res> {
  factory _$$AuthFailuresUnknowCopyWith(_$AuthFailuresUnknow value,
          $Res Function(_$AuthFailuresUnknow) then) =
      __$$AuthFailuresUnknowCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuthFailuresUnknowCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$AuthFailuresUnknowCopyWith<$Res> {
  __$$AuthFailuresUnknowCopyWithImpl(
      _$AuthFailuresUnknow _value, $Res Function(_$AuthFailuresUnknow) _then)
      : super(_value, (v) => _then(v as _$AuthFailuresUnknow));

  @override
  _$AuthFailuresUnknow get _value => super._value as _$AuthFailuresUnknow;
}

/// @nodoc

class _$AuthFailuresUnknow implements AuthFailuresUnknow {
  const _$AuthFailuresUnknow();

  @override
  String toString() {
    return 'AuthFailures.unknow()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AuthFailuresUnknow);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() emailAddressInvalid,
    required TResult Function() passwordInvalid,
    required TResult Function() fullNameInvalid,
    required TResult Function() unknow,
  }) {
    return unknow();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
  }) {
    return unknow?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? emailAddressInvalid,
    TResult Function()? passwordInvalid,
    TResult Function()? fullNameInvalid,
    TResult Function()? unknow,
    required TResult orElse(),
  }) {
    if (unknow != null) {
      return unknow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AuthFailuresEmailAddressInvalid value)
        emailAddressInvalid,
    required TResult Function(AuthFailuresPasswordInvalid value)
        passwordInvalid,
    required TResult Function(AuthFailureFullNameInvalid value) fullNameInvalid,
    required TResult Function(AuthFailuresUnknow value) unknow,
  }) {
    return unknow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
  }) {
    return unknow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AuthFailuresEmailAddressInvalid value)?
        emailAddressInvalid,
    TResult Function(AuthFailuresPasswordInvalid value)? passwordInvalid,
    TResult Function(AuthFailureFullNameInvalid value)? fullNameInvalid,
    TResult Function(AuthFailuresUnknow value)? unknow,
    required TResult orElse(),
  }) {
    if (unknow != null) {
      return unknow(this);
    }
    return orElse();
  }
}

abstract class AuthFailuresUnknow implements AuthFailures {
  const factory AuthFailuresUnknow() = _$AuthFailuresUnknow;
}
